unit Main;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.ExtCtrls, Vcl.StdCtrls;

type
  TDrawMode = (Draw, NoDraw);
  TEditMode = (NoEdit, Move, TSide, BSide, RSide, LSide, Vert1, Vert2, Vert3, Vert4);
  TType = (Def,MetaVar,MetaConst);
  TRectInfo = record
    x1,x2,y1,y2: integer;
    Txt: string[255];
    Tp: TType;
  end;
  PRectList = ^RectList;
  RectList = record
    Info: TRectInfo;
    Adr: PRectList;
  end;

  TEditorForm = class(TForm)
    canv: TImage;
    Label1: TLabel;
    procedure FormCreate(Sender: TObject);
    procedure clearScreen;
    procedure canvMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure canvMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure canvMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
  private
    DM: TDrawMode;
    EM: TEditMode;
  public
    { Public declarations }
  end;

var
  EditorForm: TEditorForm;
  RectHead: PRectList;
  CurrType: TType;
  CurrFigure: Pointer;
  tempX, tempY: integer;
const
  Tolerance = 5; // Кол-во пискелей, на которые юзеру можно "промахнуться"
implementation

{$R *.dfm}

// Добавляем новый прямоугольный объект и возвращаем ссылку на него!
function addRect(head: PRectList; x,y: integer; ftype: TType; Text:String = 'Kek'):PRectList;
var
  tmp: PRectList;
begin
  tmp := head;
  while tmp^.adr <> nil do
    tmp := tmp^.Adr;
  new(tmp^.adr);
  tmp := tmp^.Adr;
  tmp^.Adr := nil;
  with tmp^.Info do
  begin
    x1 := x;
    x2 := x;
    y1 := y;
    y2 := y;
    Txt := text;
    Tp := ftype;
  end;

  Result := tmp;
end;


// Создаем массив прямоугольных фигур
procedure createRectList(var head: PRectList);
begin
  new(head);
  head.Adr := nil;
end;

procedure TEditorForm.canvMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  DM := Draw; // Начинаем рисование
  if EM = NoEdit then
  begin
    CurrFigure := addRect(RectHead, x,y, CurrType);
  end
  else
  begin
    tempx:= x;
    tempy:= y;
  end;
end;

procedure changeCursor(Form:TForm; Mode: TEditMode);
begin
  case mode of
    NoEdit: Form.Cursor := crArrow;
    Move: Form.Cursor := crSizeAll;
    TSide: Form.Cursor := crSizeNS;
    BSide: Form.Cursor := crSizeNS;
    RSide: Form.Cursor := crSizeWE;
    LSide: Form.Cursor := crSizeWE;
    Vert1: Form.Cursor := crSizeNWSE;
    Vert2: Form.Cursor := crSizeNESW;
    Vert3: Form.Cursor := crSizeNESW;
    Vert4: Form.Cursor := crSizeNWSE;
  end;
end;

function getEditMode(status: TDrawMode; x,y: Integer; head: PRectList) :TEditMode;
var
  r:TRectInfo;
  temp: PRectList;
begin
  temp := head;
  while temp <> nil do
  begin
    R := temp^.Info;
    if status = nodraw then
    begin
      if ( (x > R.x1) and (x < R.x2) and (y > R.y1) and (y < R.y2)) then
      begin
        // Внутри объекта
        Result := Move;
      end
      else
      begin
        // За пределами объекта
        Result := NoEdit;
      end;
      if ( (x > R.x1) and (x < R.x2) and ((abs(y - R.y1) < Tolerance) or (abs(y - R.y2) < Tolerance))) then
      begin
        // Горизонтальная сторона
        if (abs(y - R.y1) < Tolerance) then
          Result := TSide
        else
          Result:= BSide;
      end;
      if ( (y > R.y1) and (y < R.y2) and ((abs(x - R.x1) < Tolerance) or (abs(x - R.x2) < Tolerance))) then
      begin
        // Вертикальная сторона
        if (abs(x - R.x1) < Tolerance) then
          Result := Lside
        else
          Result:= RSide;
      end;
      if ((abs(y-R.y1) < Tolerance) and (abs(x-R.x1) < Tolerance)) then
      begin
        // Левая верхняя вершина
        Result := Vert1;
      end;
      if (abs(y-R.y1) < Tolerance) and (abs(x-R.x2) < Tolerance) then
      begin
        // Правая верхняя вершина
        Result := Vert2;
      end;
      if (abs(y-R.y2) < Tolerance) and (abs(x-R.x1) < Tolerance) then
      begin
        // Левая нижняя вершина
        Result := Vert3;
      end;
      if (abs(y-R.y2) < Tolerance) and (abs(x-R.x2) < Tolerance) then
      begin
        // Правая нижняя вершина
        Result := Vert4;
      end;
      if result <> NoEdit then
      begin
        CurrFigure := temp;
        exit;
      end;
    end;
    temp := temp^.Adr;
  end;
end;

procedure checkFigureCoord(R: PRectList);
var
  temp:integer;
begin
  with R^.Info do
  begin
    if x1 > x2 then
    begin
      temp := x1;
      x1 := x2;
      x2:=temp;
    end;
    if y1 > y2 then
    begin
      temp := y1;
      y1 := y2;
      y2:=temp;
    end;
  end;
end;

procedure ChangeCoords(F: PRectList; EM: TEditMode; x,y:integer);
begin
  if F <> nil then
  case EM of
    NoEdit:
    begin
      F^.Info.x2 := x;
      F^.Info.y2 := y;
    end;
    Move: ;
    TSide: ;
    BSide: ;
    RSide: ;
    LSide: ;
    Vert1: ;
    Vert2: ;
    Vert3: ;
    Vert4: ;
  end;
end;

procedure drawRectFigure(Canvas:TCanvas; head:PRectList);
var
  temp:PRectList;
  R: TRectInfo;
  TextW: Integer;
  TextH: Integer;
  TX, TY: integer;
begin
  temp := head;
  while temp <> nil do
  begin
    R := temp.Info;

    TextW := canvas.TextWidth(r.txt);
    textH := Canvas.TextHeight(r.txt);

    // Расчитываем координаты, чтобы текст был по середине
    TX := r.x1 + (r.x2 - r.x1) div 2 - TextW div 2;
    TY := r.y1 + (r.y2 - r.y1) div 2 - TextH div 2;

    // Если ширина или высота блока меньше, чем текста, то подгоняем под размер текста
    if ((r.x2 - R.x1) < TextW) then
    begin
      r.x1 := r.x1 - textw div 2 - 5;
      r.x2 := r.x2 + textw div 2 + 5;
    end;
    if ((r.y2 - R.y1) < TextH) then
    begin
      r.y1 := r.y1 - textH div 2 - 5;
      r.y2 := r.y2 + textH div 2 + 5;
    end;
    Canvas.Rectangle(R.x1, R.y1, R.x2, R.y2);

    Canvas.TextOut(TX,TY, r.txt);

    temp := temp^.Adr;
  end;
end;

procedure TEditorForm.canvMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  EM := getEditMode(DM, x,y,RectHead);
  changeCursor(Self, EM); // Меняем курсор в зависимости от положения мыши
  if (DM = draw) and (currfigure <> nil)  then
  begin
    ChangeCoords(CurrFigure, EM, x,y);
    TempX:= X; // Обновляем прошлые координаты
    TempY:= Y;
    clearScreen; // Чистим экран
    drawRectFigure(canv.Canvas, RectHead);
  end;
end;

procedure TEditorForm.canvMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  DM := NoDraw; // Заканчиваем рисование
  checkFigureCoord(CurrFigure);
  drawRectFigure(canv.Canvas, RectHead);
end;

procedure TEditorForm.clearScreen;
begin
  canv.Canvas.Rectangle(0,0,canv.Width,canv.Height);
end;

procedure TEditorForm.FormCreate(Sender: TObject);
begin
  createRectList(RectHead);
  CurrType := Def;
  EM := NoEdit;
  CurrFigure := nil;
  clearScreen;
end;

end.
